library(readxl)
library(dplyr, warn.conflicts = FALSE)
library(DBI)

# Some functions ----
fix_names <- function(df) {
    colnames(df) <- tolower(colnames(df))
    df
}

is_boolean <- function(vec) {
    if (length(setdiff(unique(vec), c(NA)))==0) return(FALSE)
    length(setdiff(unique(vec), c(NA, 0, 1)))==0
}

get_booleans <- function(df) {
    temp <- unlist(lapply(df, is_boolean))
    names(temp[temp])
}

is_integer <- function(vec) {
    vec <- vec[!is.na(vec) & is.numeric(vec)]
    if (length(vec) > 0) {
        all(as.integer(vec)==vec)
    } else  {
        return(FALSE)
    }
}

get_integers <- function(df) {
    temp <- unlist(lapply(df, is_integer))
    names(temp[temp])
}

detail <-
    read_xlsx("DGLS_20181231_D.xlsx", sheet = "detail") %>%
    fix_names() %>%
    mutate_at(vars(get_booleans(.)), as.logical) %>%
    mutate_at(vars(get_integers(.)), as.integer)


ann <-
    read_xlsx("DGLS_20181231_D.xlsx", sheet = "ann") %>%
    fix_names() %>%
    mutate_at(vars(get_booleans(.)), as.logical) %>%
    mutate_at(vars(get_integers(.)), as.integer) %>%
    mutate(date = as.Date(date))

qtr <-
    read_xlsx("DGLS_20181231_D.xlsx", sheet = "qtr") %>%
    fix_names() %>%
    mutate_at(vars(get_booleans(.)), as.logical) %>%
    mutate_at(vars(get_integers(.)), as.integer) %>%
    mutate(date = as.Date(date))

# Push data ----

pg <- dbConnect(RPostgres::Postgres())

rs <- dbExecute(pg, "SET search_path TO aaer")

rs <- dbWriteTable(pg, "qtr", qtr, overwrite = TRUE, row.names = FALSE)
rs <- dbWriteTable(pg, "detail", detail, overwrite = TRUE, row.names = FALSE)
rs <- dbWriteTable(pg, "ann", ann, overwrite = TRUE, row.names = FALSE)

rs <- dbExecute(pg, "ALTER TABLE qtr OWNER TO aaer")
rs <- dbExecute(pg, "ALTER TABLE detail OWNER TO aaer")
rs <- dbExecute(pg, "ALTER TABLE ann OWNER TO aaer")

rs <- dbExecute(pg, "GRANT SELECT ON qtr TO aaer_access")
rs <- dbExecute(pg, "GRANT SELECT ON detail TO aaer_access")
rs <- dbExecute(pg, "GRANT SELECT ON ann TO aaer_access")

dbDisconnect(pg)
